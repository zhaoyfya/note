### IP协议
![[Pasted image 20230409144500.png]]

```tx
|      字段        | 长度  | 含义       | 
|:---------------:|:-----:|:-----------|
|version|4bit|4:表示IPv4|\
| | |6:表示IPv6|                                                                       
|IHL|4bit|首部长度，如果不带Option字段，则为20，最长为60，该值限制了记录路由选项。以4字节为一个单位|
|Type of Service|8bit|服务类型。只有在有QoS差分服务要求时这个字段才起作用|                                          
|Total Length|16bit|总长度，整个IP数据报的长度，包括首部和数据之和，单位为字节，最长65535，总长度必须不超过最大传输单元MTU|
|Identification|16bit|标识，主机每发一个报文，加1，分片重组时会用到该字段|                                                      
|Flags|3bit|标志位:|\
| | |Bit 0: 保留位，必须为0|\
| | |Bit 1: DF（Don't Fragment），能否分片位，0表示可以分片，1表示不能分片|\
| | |Bit 2: MF（More Fragment），表示是否该报文为最后一片，0表示最后一片，1代表后面还有|
|Fragment Offset|12bit|片偏移：分片重组时会用到该字段。表示较长的分组在分片后，某片在原分组中的相对位置。以8个字节为偏移单位|
|Time to Live|8bit|生存时间：可经过的最多路由数，即数据包在网络中可通过的路由器数的最大值|
|Protocol|8bit|上层协议常见值:|\
| | |0:保留Reserved|\
| | |1:ICMP, Internet Control Message [RFC792]|\
| | |2:IGMP, Internet Group Management [RFC1112]|\
| | |3:GGP, Gateway-to-Gateway [RFC823]|\
| | |4:IP in IP (encapsulation) [RFC2003]|\
| | |6:TCP Transmission Control Protocol [RFC793]|\
| | |17:UDP User Datagram Protocol [RFC768]|\
| | |20:HMP Host Monitoring Protocol [RFC 869]|\
| | |27:RDP Reliable Data Protocol [ RFC908 ]|\
| | |46:RSVP (Reservation Protocol)|\
| | |47:GRE (General Routing Encapsulation)|\
| | |50:ESP Encap Security Payload [RFC2406]|\
| | |51:AH (Authentication Header) [RFC2402]|\
| | |54:NARP (NBMA Address Resolution Protocol) [RFC1735]|\
| | |58:IPv6-ICMP (ICMP for IPv6) [RFC1883]|\
| | |59:IPv6-NoNxt (No Next Header for IPv6) [RFC1883]|\
| | |60:IPv6-Opts (Destination Options for IPv6) [RFC1883]|\
| | |89:OSPF (OSPF Version 2) [RFC 1583]|\
| | |112:VRRP (Virtual Router Redundancy Protocol) [RFC3768]|\
| | |115:L2TP (Layer Two Tunneling Protocol)|\
| | |124:ISIS over IPv4|\
| | |126:CRTP (Combat Radio Transport Protocol)|\
| | |127:CRUDP (Combat Radio User Protocol)|\
| | |132:SCTP (Stream Control Transmission Protocol)|\
| | |136:UDPLite [RFC 3828]|\
| | |137:MPLS-in-IP [RFC 4023]|
|Header Checksum|16bit|首部检验和，只检验数据包的首部，不检验数据部分;这里不采用CRC检验码，而采用简单的计算方法|
|Source Address|32bit|源IP地址|
|Destination Address|32bit|目的IP地址|
|Options|可变|选项字段，用来支持排错，测量以及安全等措施，内容丰富（请参见下表）。选项字段长度可变，从1字节到40字节不等，取决于所选项的功能|
|Padding|可变|填充字段，全填0|
```

![[31.webp]]

### TCP协议
![[Pasted image 20230409155959.png]]
```tx
|      字段        | 长度  | 含义       | 
|:---------------:|:-----:|:-----------|
|Source Port|16bit|源端口:标识哪个应用程序发送|
|Destination Port|16bit|目的端口:标识哪个应用程序接收|  
|Sequence Number|32bit|序号字段:TCP链接中传输的数据流中每个字节都编上一个序号。序号字段的值指的是本报文段所发送的数据的第一个字节的序号|
|Acknowledgment Number|32bit|确认号:是期望收到对方的下一个报文段的数据的第1个字节的序号，即上次已成功接收到的数据字节序号加1。只有ACK标识为1，此字段有效|
|Data Offset|4bit|数据偏移，即首部长度，指出TCP报文段的数据起始处距离TCP报文段的起始处有多远，以32比特（4字节）为计算单位。最多有60字节的首部，若无选项字段，正常为20字节|                                                      
|Reserved|6bit|保留，必须填0|
|URG|1bit|紧急指针有效标识：它告诉系统此报文段中有紧急数据，应尽快传送（相当于高优先级的数据）|
|ACK|1bit|确认序号有效标识：只有当ACK=1时确认号字段才有效。当ACK=0时，确认号无效|
|PSH|1bit|标识接收方应该尽快将这个报文段交给应用层：接收到PSH = 1的TCP报文段，应尽快的交付接收应用进程，而不再等待整个缓存都填满了后再向上交付|
|RST|1bit|重建连接标识：当RST=1时，表明TCP连接中出现严重错误（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立连接|
|SYN|1bit|同步序号标识：用来发起一个连接。SYN=1表示这是一个连接请求或连接接受请求|
|FIN|1bit|发端完成发送任务标识：用来释放一个连接，FIN=1表明此报文段的发送端的数据已经发送完毕，并要求释放连接|
|Window|16bit|窗口：TCP的流量控制，窗口起始于确认序号字段指明的值，这个值是接收端正期望接收的字节数。窗口最大为65535字节|
|Checksum|16bit|校验字段，包括TCP首部和TCP数据，是一个强制性的字段，一定是由发端计算和存储，并由收端进行验证。在计算检验和时，要在TCP报文段的前面加上12字节的伪首部|

|Urgent Pointer|16bit|紧急指针，只有当URG标志置1时紧急指针才有效。TCP的紧急方式是发送端向另一端发送紧急数据的一种方式。紧急指针指出在本报文段中紧急数据共有多少个字节（紧急数据放在本报文段数据的最前面）|
|Options|可变|选项字段。|\
| | |TCP协议最初只规定了一种选项，即最长报文段长度（数据字段加上TCP首部），又称为MSS。MSS告诉对方TCP“我的缓存所能接收的报文段的数据字段的最大长度是MSS个字节”|\
| | |新的RFC规定有以下几种选型：选项表结束，无操作，最大报文段长度，窗口扩大因子，时间戳|\
| | |窗口扩大因子：3字节，其中一个字节表示偏移值S。新的窗口值等于TCP首部中的窗口位数增大到（16+S），相当于把窗口值向左移动S位后获得实际的窗口大小|\
| | |时间戳：10字节，其中最主要的字段是时间戳值（4字节）和时间戳回送应答字段（4字节）|\
| | |选项确认选项|
|Padding|可变|填充字段，用来补位，使整个首部长度是4字节的整数倍|
|data|可变|TCP负载|
```


>2.三次握手与四次挥手过程

![[Pasted image 20230409193905.png]]


![[Pasted image 20230313220923.png]]

>1.为什么是三次握手?
```
能最快确认客户端和服务端双方的收发能力
```

>2.三次握手作用?
```
1.防止「历史连接」初始化了连接，避免了资源浪费，本质就是双方需要互相确认;
2.确定双方端口;
3.同步双方序列号和确认号;
4.交换TCP滑动窗口大小;
```

>3.半连接队列和全连接队列
```
半连接队列：保存客户端发送的syn（第一次）的连接，客户端状态：syn_send 
全连接队列：保存三次握手之后的连接,当全连接队列满的时候会丢包
当服务端发送syn_ack（第二次）后未收到客户端ack（第三次），服务端会隔一段时间重传（1s 2s 4s 8s 以便以指数增长）
```

>4.ISN号是固定吗?
```
不是，是动态生成的
ISN = M + F(localhost, localport, remotehost, remoteport)。
M:一个计时器，这个计时器每隔 4 微秒加 1。
F:一个 Hash 算法，根据源 IP、目的 IP、源端口、目的端口生成一个随机数值。要保证 Hash 算法不能被外部轻易推算得出，用 MD5 算法是一个比较好的选择。
随机数是会基于时钟计时器递增的，基本不可能会随机成一样的初始化序列号
```

>5.SYN攻击（泛洪攻击）：
```
客户端使用大量随机IP地址像服务端请求连接，导致服务端半连接队列满而丢弃正常连接
防御SYN攻击:
1.缩短超时（SYN Timeout）时间
2.增加最大半连接数
3.过滤网关防护
4.SYN cookies技术(重点)
```

>6.三次握手可以携带数据吗？为什么只有第三次可以携带数据？
```
三次握手的第三次可以携带数据；
第一、二次携带数据更容易让服务端收到恶意攻击
第三次握手时客户端已经处于  ESTABLISHED 状态，而且也知道服务端接收和发送报文能力都是正常的，此时携带数据给服务端完全没有问题
```

>7.三次握手每次丢包都会发生什么？
```
第一次握手包丢:
服务端没收到SYN包也就不会给客户端回应ACK，所以会触发客户端的超时重传，时间间隔成指数增长1s、2s、4s、8s

第二次握手包丢:
客户端没有收到服务端响应ACK，会触发超时重传SYN包；客户端也没有收到服务端发来的SYN包，所以不会给服务端响应ACK，因此服务端也会触发超时重传SYN+ACK

第三次握手包丢:
服务端没有收到来自客户端的ACK，会触发服务端的超时重传SYN+ACK
```

>8.四次挥手每次丢包都会发生什么？
```
第一次挥手丢包(主动方的FIN)：
客户端发送FIN包丢包后，服务端无法回复ACK，所以客户端会触发超时重传，当超过重传次数上限就会主动close

第二次挥手丢包(被动方的ACK)：
客户端发送FIN包，服务端回复ACK丢包，客户端无法收到ACK而触发超时重传，客户端会重新发送FIN包，直到达到重传上限，若客户端选择关闭连接的是close接口，则客户端会经过60s后自动关闭，若客户端选择关闭连接接口是shutdown，客户端则还具有接收能力，则客户端会一直等待服务端的ACK响应。

第三次挥手丢包：
服务端发送FIN包丢包，客户端未收到而无法回复ACK，导致服务端触发超时重传，当到达重传上限则会自动关闭，客户端也会自动关闭

第四次挥手丢包：
服务端发送FIN包，客户端回复ACK丢包导致服务端未收到ACK响应，服务端触发超时重传FIN包，当达到重传上线则服务端自动关闭，客户端每次收到服务端的FIN会重置定时器2MLS，直到服务端关闭不在发送FIN来触发客户端定时器重置后客户端经过2MLS时间关闭连接
```

>9.为什么是四次挥手?
```
因为请求关闭连接的一端发送FIN包后，另一端可能还有报文未发送完，所以需要另一端将全部报文发送完之后，也发出FIN断开连接
```

>10.四次挥手合并成三次的原因？
```
因为TCP默认开启TCP延迟确认机制：
情况一：回应ACK时没有数据包要发送，会进行延迟发送(假设200ms)，若一直没有数据需要发送，则200ms后发送ACK；
情况二：回应ACK时没有数据包要发送，会进行延迟发送(假设200ms)，100ms时有数据包需要发送，则立即发送数据包+ACK；
情况三：当在延迟发送等待期间又收到对方的数据，则不管是否有数据要发送立即发送ACK；
```

>11.IP层会分片，为什么TCP层还需要MMS？
```
因为IP层本身没有重传机制，当IP分片丢失时，TCP层无法保序
```

>12.rest报文出现的原理？
```
socket关闭的系统调用有两种，分别是close和shutdown;
close：同时关闭socket收发两个方向，但是在多进程/线程共享同一个socket的时候调用close，是对socket的引用计数-1，并不会影响其他进程继续使用该socket;
shutdown：可以指定socket只关闭发送方向而不关闭读取方向，多进程/多线程共享同一个socket，shutdown则不管引用计数，直接使得该socket不可用，然后发出FIN报文，如果有别的进程企图使用该 socket，将会受到影响。

所以rest包是因为主动关闭方调用了close关闭而引起的没有接收能力
```

>13.TCP异常终止（reset报文）
- 客户端尝试与服务器未对外提供服务的端口建立TCP连接，服务器将会直接向客户端发送reset报文：
![[Pasted image 20230314114119.png]]
- 客户端和服务器的某一方在交互的过程中发生异常（如程序崩溃等），该方系统将向对端发送TCP reset报文，告之对方释放相关的TCP连接，如下图所示：
![[Pasted image 20230314114202.png]]
![](https://img-my.csdn.net/uploads/201210/08/1349695990_5546.png) 
- 接收端收到TCP报文，但是发现该TCP的报文，并不在其已建立的TCP连接列表内，则其直接向对端发送reset报文，如下图所示：
![[Pasted image 20230314114253.png]]
- 在交互的双方中的某一方长期未收到来自对方的确认报文，则其在超出一定的重传次数或时间后，会主动向对端发送reset报文释放该TCP连接，如下图所示：
![[Pasted image 20230314114356.png]]
- 有些应用开发者在设计应用系统时，会利用reset报文快速释放已经完成数据交互的TCP连接，以提高业务交互的效率，如下图所示：  
![[Pasted image 20230314114403.png]]

>1. 打开一个网页具体做了那些事情？
```
1.http解析域名，组织请求报文;
2.DNS域名解析，获取server端IP地址（浏览器先查自身缓存->操作系统缓存->本地host文件->本地DNS->从根域名逐步询问）;
3.封装传输层（TCP/UDP）报文，其中包含sport/dport，seq/ack，消息类型flag，MSS/滑动窗口等;
4.封装网络层（IP）报文,其中包含版本号,头长,总长,分片标记,TTL,协议号,校验和,sip/dip和扩展选项（三次握手才有）,查route表确定目的IP;
5.封装mac层报文，查询ARP表确定出口mac地址，首次发送ARP报文广播查询;
6.将数据包发送到服务端;
```

>4. ftp主动模式与被动模式
```
主动模式：服务端去连接客户端，客户端告诉服务端采用主动模式，然后服务端使用20端口连接
被动模式：客户端连接服务端，客户端告诉服务端采用被动模式，然后服务端告诉客户端数据连接端口，客户端通过告知端口连接服务端
```

>5.邮件协议